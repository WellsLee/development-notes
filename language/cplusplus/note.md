# 《笔记来源于C++ prime第三版》

# 声明与定义的区别
* 变量：是否分配内存。
* 函数：是否有函数体。
* 类：是否有类体。
* int \*&v1 从右向走读，v是一个引用，它引用一个指向int类型的指针。

# 函数重载
* 仅函数返回值不同不能重载，因为函数调用可以忽略返回值，这样则无法判断调用的是哪个重载函数。
* 全局重载操作符比成员重载操作符多了一个参数，对于成员操作符，this指针被用作隐式的第一个参数。
* 只有在C++预定义的操作符才可以被重载。
* point->action() 如果point是某个类类型的指针。则这个语句使用内置成员操作符箭头的语义；如果point是一个类或者引用，则查找这个类的重载成员操作符箭头。
* 为了区分后置与前置操作符的声明，重载的++和--后置操作符的声明有一个额外的int类型的参数。

# 构造函数
* 构造函数一般为public，如不允许创建对象则为private，如单例。
* 默认构造函数：指为所有参数都提供了默认值的构造函数,通常是指无参的构造函数，这并不意味它不能接受实参。
* 子类不会继承父类的构造函数和析构函数。
* 常用错误，按如下方式声明一个用缺省构造函数初始化的对象：Acount acount();
* 只有当没有构造函数或声明了缺省构造函数时，才能不指定实参来定义类对象。
* 在实践中，如果定义了其他的构造函数，则也有必要提供一个缺省构造函数。
* 构造函数不能用const或volatile关键字来声明。一个const类对象在其构造函数完成到析构函数开始这段时间才被认为是const的，volatile也一样。
* explicit修饰符通知编译器不要提供隐式转换，explicit只能应用在构造函数上。
* 缺省构造函数是指不需要用户指定实参就能够被调用的构造函数，这并不意味着它不能接受实参。
* 在实际中，非公有的构造函数的主要用处：1）防止用一个类的对象向该类的另一个对象作拷贝；2）指出只有当一个类被用作基类时，构造函数才能被调用（protected）。
* 用一个类对象初始化该类的另一个对象被称为缺省按成员初始化，即以此拷贝每一个非静态成员实现的。类的设计者也可以通过提供拷贝构造函数来改变这种缺省的行为。
* 在某些应用中，通过显式初始化表，用常量初始化大型数据结构比较有效。
* const和引用数据成员必须是在成员初始化表中被初始化，否则，就会产生编译错误。每个成员在成员初始化列表中只能出现一次，初始化的顺序不是由名字在初始化表中的顺序决定的，而是由成员在类中被声明的顺序决定的。

# 析构函数
* 只能定义一个析构函数。
* 只有当delete表达式中的指针指向一个带有析构函数的类类型时，才会调用析构函数。
* 内联析构函数可能是程序代码膨胀的一个原因，因为它被插入到函数中每一个退出点，以析构每一个局部对象。

# 虚函数
* 非虚函数的调用在编译时刻选择被调用的函数，而虚函数要等到运行时刻。

# 异常
* 一个catch语句由三部分组成：关键字catch，在括号中的单个类型或者单个对象声明以及复合语句。
* 异常声明类似于按值传递，catch子句的异常声明也可以为引用声明，可防止不必要的对象拷贝。
* throw像函数调用，catch像函数定义。
* throw必须抛出一个class类型的对象，example：throw popOnEmpty()
* 一种能处理全部异常的catch子句：
catch(...) {
//处理所有的异常
}
* 异常规范例子：void pop(int &value) throw (popOnEmpty);
* 空的异常规范保证函数不会抛出任何异常：void no\_problem() throw();
* 如果一个函数声明没有指定异常规范，则该函数可以抛出任何类型的异常。

# 字符串
* 如果两个字符串相邻，C++会将它们连在一起。

# 引用
* 引用又称别名，主要被用作函数的形参。指针和引用有两个主要的区别：引用必须指向一个对象；如果用一个引用给另一个引用赋值，改变的是被引用的对象而不是引用本身。
* 引用作为函数返回值最大好处是，在内存中不产生被返回值的副本。
* 引用参数的一个重要用法是，它允许我们在有效实现重载操作符的同时，还能保证用法的直观性。
* 当声明一个返回引用的函数时，2个容易犯的错误：1）返回一个指向局部对象的引用。2）对返回值的修改都将改变被返回的实际对象。

# vector
* vector类提供内置数组的一种替代表示。
* 为了提供效率，vector并不是随着每一个元素的插入而增长自己，每次增长的空间会比需要的空间大一些。对于小的对象，vector比list效率高。
* 一般，类对象的vector仅仅最适合于元素的插入，即定一个空的vector，如果我们先预算出要插入的数目，那么可以预留相应大小的存储区。(reserve)

# volatile
* volatile提示编译器该对象容易被改变，编译器不能武断地对引用这些对象的代码做优化处理。
* 一个volatile类对象，只有volatile成员函数，构造函数和析构函数可以被调用。

# inline
* 在类定义内部定义的成员函数，在缺省情况下被设置为inline。在类体外定义的内联成员函数，应该被包含在含有该类定义的头文件中。

# union
* 缺省情况下，union的成员都是public，也可以声明为public，private或者protected。
* union不能有静态数据成员或引用成员，如果一个类定义了构造，析构或拷贝赋值操作符，则它也不能成为union的成员。
* 匿名的union不能有私有或保护的成员，也不能定义成员函数。

# 位域
* 一种节省空间的成员。

# 函数
* 内置数组类型不能用作函数返回类型。
* C++是一种强类型语言，每个函数调用的实参在编译期间都要经过类型检查。
* 函数参数可以是多维数组，参数必须指明第一维以外的所有维的长度。
* 设计带有缺省实参函数的工作就是排列参数表的参数，使最有可能用户指定值的参数排前面，最可能缺省的参数排后面。

# 函数模板
* 模板非类型参数有一个普通的参数声明构成，代表模板中定义的常量。example：template <typename Type, int size>
* 在函数模板参数表中，typename和class的意义相同，可以互换使用。

# 内存分配
* 对于用new分配的数组，只有第一维可以在运行时刻计算获得，其他的维必须在编译时刻已知。
* 试图用new创建一个内置类型的const数组会导致编译错误。
* new允许程序员将对象创建在已经分配好的内存中。
* delete操作会对指针是否为空判断，所以delete之前没用必要判断指针是否为空。

# 友元
* 友元声明以关键字friend开头，只能出现在类的声明中，因为友元不是类的成员，所以它不受private，public和protected的影响。
* 友元可以是一个名字空间函数或者另一个类的成员函数或者是一个完整的类。 

# 类
* 当一个类的类头被看到，它就视为已经被声明了，所以一个类可以用指向自身的指针或引用作为数据成员。（如链表）
* const对象不能调用非const成员函数，构造函数和析构函数除外。const成员函数可以被相同参数的非const成员函数重载，类的对象是否const决定调用哪个函数。
* multable成员总可以被修改，即使是在const成员函数中。
* static数据成员的初始化不应该放在头文件，应该放在函数定义的文件中。作为特例，整形的const静态数据成员可以在类体中初始化，这时类定义之外的定义不能再指定初始值。
* 两种方式访问static数据成员：1）使用对象的成员访问操作符；2）用类名::静态数据成员。
* 静态成员函数声明在类体中函数声明中加上关键字static，而出现中类体外的函数定义不能指定关键字static。
* 嵌套类也可以被定义在其外围类之外。
* 嵌套类不能直接访问其外围类的非静态成员，即使这些成员是公有的，任何对外围类的非静态成员的访问都要求通过外围类的指针，引用或对象来完成。但嵌套类可以访问外围类的静态成员，类型名，枚举值。类型名是一个typedef名字，枚举类型名或是一个类名。

# 域
全局域解析操作符，example：::list


# 泛型算法（略）
