# 笔记来源于C++ prime第三版

# 声明与定义的区别
* 变量：是否分配内存。(类的声明和定义是否不符合这个原则？)
* 函数：是否有函数体。
* int \*&v1 从右向走读，v是一个引用，它引用一个指向int类型的指针。

# 函数重载
* 仅函数返回值不同不能重载，因为函数调用可以忽略返回值，这样则无法判断调用的是哪个重载函数。

# 构造函数
* 构造函数一般为public，如不允许创建对象则为private，如单例。
* 默认构造函数：指为所有参数都提供了默认值的构造函数,通常是指无参的构造函数，这并不意味它不能接受实参。
* 子类不会继承父类的构造函数和析构函数。

# 虚函数
* 非虚函数的调用在编译时刻选择被调用的函数，而虚函数要等到运行时刻。

# 异常
* 一个catch语句由三部分组成：关键字catch，在括号中的单个类型或者单个对象声明以及复合语句。
* 异常声明类似于按值传递，catch子句的异常声明也可以为引用声明，可防止不必要的对象拷贝。
* throw像函数调用，catch像函数定义。
* throw必须抛出一个class类型的对象，example：throw popOnEmpty()
* 一种能处理全部异常的catch子句：
catch(...) {
//处理所有的异常
}
* 异常规范例子：void pop(int &value) throw (popOnEmpty);
* 空的异常规范保证函数不会抛出任何异常：void no\_problem() throw();
* 如果一个函数声明没有指定异常规范，则该函数可以抛出任何类型的异常。

# 字符串
* 如果两个字符串相邻，C++会将它们连在一起。

# 引用
* 引用又称别名，主要被用作函数的形参。指针和引用有两个主要的区别：引用必须指向一个对象；如果用一个引用给另一个引用赋值，改变的是被引用的对象而不是引用本身。
* 引用作为函数返回值最大好处是，在内存中不产生被返回值的副本。
* 引用参数的一个重要用法是，它允许我们在有效实现重载操作符的同时，还能保证用法的直观性。
* 当声明一个返回引用的函数时，2个容易犯的错误：1）返回一个指向局部对象的引用。2）对返回值的修改都将改变被返回的实际对象。

# vector
* vector类提供内置数组的一种替代表示。
* 为了提供效率，vector并不是随着每一个元素的插入而增长自己，每次增长的空间会比需要的空间大一些。对于小的对象，vector比list效率高。

# volatile
* volatile提示编译器该对象容易被改变，编译器不能武断地对引用这些对象的代码做优化处理。

# inline
* 在类定义内部定义的成员函数，在缺省情况下被设置为inline。在类体外定义的内联成员函数，应该被包含在含有该类定义的头文件中。

# 函数
* 内置数组类型不能用作函数返回类型。
* C++是一种强类型语言，每个函数调用的实参在编译期间都要经过类型检查。
* 函数参数可以是多维数组，参数必须指明第一维以外的所有维的长度。
* 设计带有缺省实参函数的工作就是排列参数表的参数，使最有可能用户指定值的参数排前面，最可能缺省的参数排后面。

# 函数模板
* 模板非类型参数有一个普通的参数声明构成，代表模板中定义的常量。example：template <typename Type, int size>
* 在函数模板参数表中，typename和class的意义相同，可以互换使用。

# 内存分配
* 对于用new分配的数组，只有第一维可以在运行时刻计算获得，其他的维必须在编译时刻已知。
* 试图用new创建一个内置类型的const数组会导致编译错误。
* new允许程序员将对象创建在已经分配好的内存中。
* delete操作会对指针是否为空判断，所以delete之前没用必要判断指针是否为空。

# 泛型算法（略）
